---
layout: post
category : 算法
tagline: DP
tags : [DP,动态规划,斐波那契数列]
---
{% include JB/setup %}

## 什么是动态规划

>通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。

>动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。

以上是来自维基百科的解释。动态规划一般简称为DP。动态规划的概念比较抽象，就是把一个大问题分解为具有一定规律的一些小问题，通过对这些小问题的解进行 **动态** 地组合或者其他方式最终形成大问题的解。

因为可以分解为小问题，所以其实可以用动态规划解决的问题，也是可以用穷举法或是递归法解决的，动态规划相对于其他两种方法，最大的区别就是动态规划会缓存小问题的解，以此大量减少重复计算的时间，是一种时间换空间的算法。

听起来很复杂是吗？别担心，这些文字只是帮你建立一个大概的印象，并没有要求像小学古诗词背诵下来。印象建立后，再看下后面的例子，就会有不一样的感受。

## 动态规划一般步骤

- 建立 **状态转移方程**

状态转移方程是动态规划中的一个专有名词，可以理解为数学归纳法中中间态的那个方程式。这个过程就是一个把现实问题转化为数学问题的塑摸过程。处理一个动态规划的问题，花在这个步骤的时间可能会超过60%。

- 注意边界条件

处理动态规划问题要特别注意问题开始的起始条件或结束条件。这个还是和数学归纳法类似，需要给定一个合适的起始步骤。

- 转化为代码

这个需要注意一个细节。一般我们在建立状态转移方程时，是需要从大问题的最后一步开始反推的。但是转化为代码后，是需要从最开始的步骤开始推向最后的步骤，因为我们需要缓存开始步骤之后的小问题的解。

## 简单例子
很多地方都喜欢用背包问题作为动态规划的开始，但我觉得那个问题还是太过复杂，会阻碍学习的热情。因此挑个更容易点的话题--斐波那契数列。

简单说下斐波那契数列，就是当前的数是前面两个数字之和，像这个样子。
1 1 2 3 5 8 13...

大家一般都会用递归的方法来接
```
f(n) = f(n-1) + f(n-2)
```

但是现在我们可以尝试用动态规划的方法来解这个问题。

按上面的步骤来走。

- 建立状态转移方程

这个问题这个步骤比较简单，因为方程就是递归用的那个公式
```
f(n) = f(n-1) + f(n-2)
```

- 注意边界条件

很容易注意到，这个问题的边界是第一个和第二个数字（两个1），是不按照这个公式来走的，所以要特殊处理。


- 转化为代码

```
int fibonacci(int n) {
    // 处理边界条件
    if (n <= 0) {
        return 0;
    }
    if (n <= 2) {
        return 1;
    }
    // 定义一个数组用来缓存之前计算结果的解。
    // 因为数组初始第一个元素的索引是0，与我们直观感受不同，所以特地把第一个元素冗余了，因此需要申请n+1个元素。
    int cachedResult = new int[n + 1];
    // 冗余用
    cachedResult[0] = 0;
    // 边界条件使用
    cachedResult[1] = 1;
    cachedResult[2] = 1;
    // 为了要缓存之前计算的值，需要从最小的解开始算起。
    // 除去前两个的边界条件，应该从3开始。
    for (int i = 3; i <= n; i++) {
        // 将状态转移方程带入
        cachedResult[i] = cachedResult[i - 1] + cachedResult[i - 2];
    }
    // 我们需要的是n的值，取缓存里的n元素即可
    return cachedResult[n];
}
```
## 引申例子

我们可以看一个更贴近现实的例子，由此来发现这个算法的美妙。

> 假设有一排阶梯，有n个台阶，你正准备通过这排阶梯上楼，可以一次上一个台阶，也可以一次上两个台阶。请问排上这个阶梯，一共有多少种方法？

第一步还是建立状态转移方程。
先假设我们走上n个台阶的解是
```
F(n)
```
刚才有提过，建立状态转移方程从最后一步反向推回来更容易完成。

我们可以想象现在我们现在已经在阶梯的顶端了。那么最后一步怎么上到顶端的呢？只有 **两种** 可能--我们可能走最后一个台阶上来的，也可能是一次性跨上最后两个台阶上来的。

如果是走最后一个台阶上来的，那么更前面的步骤就是n-1个台阶的所有可能走法，可以记做
```
F(n-1)
```

如果是一次性跨上最后两个台阶上来的，那么更前面的步骤就是n-2个台阶的所有可能走法，可以记做
```
F(n-2)
```

所以上到阶梯最顶端的所有走法就是以上两种可能的走法的总和，即
```
F(n) = F(n-1) + F(n-2)
```

是不是有很眼熟的感觉？现实生活和数学的联系有时就是这么奇妙。

后面的边界条件和编码大家可以自己动手试试。

最后提醒下，这个问题的边界条件和斐波那契数列有所不同。