---
layout: post
category : 数据库
tagline: MySQL隔离等级
tags : [MySQL]
---
{% include JB/setup %}

| 隔离级别                   | 脏读（Dirty Read）       | 不可重复读（NonRepeatable Read）     | 幻读（Phantom Read）   |
| -------------------------- | ------------------------ | ------------------------------------ | ---------------------- |
|未提交读（Read uncommitted）| 可能                     | 可能                                 | 可能                   |
|已提交读（Read committed）  | 不可能                   | 可能                                 | 可能                   |
|可重复读（Repeatable read） | 不可能                   | 不可能                               | 可能                   |
|可串行化（Serializable ）   | 不可能                   | 不可能                               | 不可能                 |

- 未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据
- 提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)
- 可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读
- 串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞

- 脏读 (Dirty Reads) : 一个事务正在访问并修改数据库中的数据但是没有提交，但是另外一个事务可能读取到这些已作出修改但未提交的数据。这样可能导致的结果就是所有的操作都有可能回滚，比如第一个事务对数据做出的修改可能违背了数据表的某些约束，破坏了完整性，但是恰巧第二个事务却读取到了这些不正确的数据造成它自身操作也发生失败回滚。
- 不可重复读取(Non-Repeatable Reads):  A 事务两次读取同一数据，B事务也读取这同一数据，但是 A 事务在第二次读取前B事务已经更新了这一数据。所以对于A事务来说，它第一次和第二次读取到的这一数据可能就不一致了。
- 幻读(Phantom Reads): 与不可重复读有点类似，都是两次读取，不同的是 A 事务第一次操作的比如说是全表的数据，此时 B 事务并不是只修改某一具体数据而是插入了一条新数据，而后 A 事务第二次读取这全表的时候就发现比上一次多了一条数据，发生幻觉了。