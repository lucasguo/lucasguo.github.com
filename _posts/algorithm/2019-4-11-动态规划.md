---
layout: post
category : 算法
tagline: DP
tags : [DP,动态规划,斐波那契数列]
---
{% include JB/setup %}

## 一切从斐波那契数列说起

斐波那契数列，就是当前的数是前面两个数字之和，像这个样子。

1 1 2 3 5 8 13 21...

总结起来数学公式是：

```
f(n) = f(n-1) + f(n-2)       ......(1)
```

现在我们需要个方法，传入n，输出第n个斐波那契数列数组元素的值。

## 用动态规划代码解决它！

先把什么是动态规划放一边，让我们先看看源码。

```
int fibonacci(int n) {
    // 处理不满足公式(1)的数据
    if (n <= 0) {
        return 0;
    }
    if (n <= 2) {
        return 1;
    }
    // 定义一个数组用来缓存每级计算结果的解。
    int cache = new int[n + 1];
    // 冗余用
    cache[0] = 0;
    // 准备不满足公式(1)的数据
    cache[1] = 1;
    cache[2] = 1;
    // 从可以用公式的最小数3开始，逐个将结果往前推并缓存
    for (int i = 3; i <= n; i++) {
        // 关键代码，带入公式(1)
        cache[i] = cache[i - 1] + cache[i - 2];
    }
    // 我们需要的是n的值，取缓存里的n元素即可
    return cache[n];
}
```
关键部分的逻辑如下图，其中展示了前4个循环

![](/images/fibonacci.png)

## 和递归算法啥区别？

关于斐波那契数列，我们看过更多的解法可能是这样：

```
int fibonacci(int n) {
    // 处理不满足公式(1)的数据
    if (n <= 2) {
        return 1;
    }
    // 套用公式(1)
    return fibonacci(n - 1) + fibonacci(n - 2);
}
```

首先说明一点，代码的长短和程序的运行效率无关！无关！无关！
递归算法代码虽然精简，但是所有项都是1+1开始一步步往上算，并没法重复利用结果，复杂度是**O(2^n)**，而动态规划算法只需要**O(n)**，可以手工计时测试感受下效率。我这测试结果是：

```
n=35

动态规划：39ms

递归：0ms
```

另外我们也可以得知一点，可以用递归解决的问题，基本都可以用动态规划算法更高效的实现。

## 是时候总结下动态规划

动态规划算法一般简称为DP算法，可以简单的看做小学学的数学归纳法，要做的事情有两件：
- 归纳出一个子项间关系的公式
- 约束起始、结束等边界条件

其中第一步归纳的公式有个专有名词，叫“**状态转移方程**”。
动态规划的思考方式一般从完成式往前推最后一步能做些什么，以此观察能出现什么可以提取的状态转移方程。

但是在归纳完成再进行代码实现时，一般是从第一步开始走，以便虑将子项的结果尽量的缓存起来以提升效率。

最后看下维基百科的说法：

>通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。

>动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。

## 挑战一个现实问题！

> 假设有一排阶梯，有n个台阶，你正准备通过这排阶梯上楼，可以一次上一个台阶，也可以一次上两个台阶。请问排上这个阶梯，一共有多少种方法？

第一步还是建立状态转移方程。
先假设我们走上n个台阶的解是
```
F(n)
```
刚才有提过，建立状态转移方程从最后一步反向推回来更容易完成。

我们可以想象现在我们现在已经在阶梯的顶端了。那么最后一步怎么上到顶端的呢？只有 **两种** 可能--我们可能走最后一个台阶上来的，也可能是一次性跨上最后两个台阶上来的。

如果是走最后一个台阶上来的，那么更前面的步骤就是n-1个台阶的所有可能走法，可以记做
```
F(n-1)
```

如果是一次性跨上最后两个台阶上来的，那么更前面的步骤就是n-2个台阶的所有可能走法，可以记做
```
F(n-2)
```

所以上到阶梯最顶端的所有走法就是以上**两种可能的走法的总和**，即
```
F(n) = F(n-1) + F(n-2)
```

是不是有很眼熟的感觉？现实生活和数学的联系有时就是这么奇妙。

后面的边界条件和编码大家可以自己动手试试。

最后提醒下，这个问题的边界条件和斐波那契数列有所不同。